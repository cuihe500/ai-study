---
sidebar_position: 4
---

# 第一次让AI写代码

## 本章要点

在上一章，我们一起逛了AI编程工具的"兵器库"，了解了各种工具的特点和选择建议。但了解工具和实际使用是两回事。这一章，我想带你真正动手，完成你的第一次AI编程体验。你会学到如何向AI描述你的需求，如何审核AI生成的代码，以及如何在这个过程中建立正确的使用心态。当你读完这一章，我相信你会有一种"原来真的可以这样"的感叹。

## 准备工作：安装Cursor

在开始之前，我们需要先准备好工具。虽然你可以选择任何AI编程工具来实践，但我建议从Cursor开始。原因很简单：它是目前AI原生体验最完整的编辑器，上手门槛低，而且免费版就已经足够强大。

### 下载与安装

访问 Cursor 的官网（cursor.com），你会看到一个醒目的下载按钮。点击它，下载适合你操作系统的版本。安装过程和普通软件没有区别——Mac用户拖拽到应用程序文件夹，Windows用户运行安装程序，一路"下一步"即可。

安装完成后打开Cursor，你会发现界面非常熟悉——如果你之前用过VS Code，你几乎不需要任何学习成本。这正是Cursor的聪明之处：它基于VS Code构建，让你可以把所有精力都放在学习AI功能上，而不是重新学习一个新编辑器。

### 认识Cursor 2.0的新界面

2025年，Cursor发布了2.0版本，带来了一次重大的界面革新。如果你打开最新版的Cursor，你会发现它与传统IDE有一个明显的不同：**界面从"以文件为中心"变成了"以Agent为中心"**。

这意味着什么呢？传统的代码编辑器把文件浏览器放在左侧，你首先要选择文件，然后编辑代码。而Cursor 2.0的新界面把Agent面板放在了核心位置——你不再需要先想"我要打开哪个文件"，而是直接告诉Agent"我想做什么"，让Agent帮你处理文件和代码的细节。

当然，如果你更习惯传统方式，Cursor也提供了切换选项。你可以随时回到经典的IDE布局，文件浏览器、代码编辑区、终端面板——一切都很熟悉。这种灵活性让Cursor既能吸引想尝试新鲜事物的探索者，也能照顾喜欢稳定习惯的老用户。

### 初次配置

第一次启动Cursor时，它会问你几个问题：

**是否从VS Code迁移设置？** 如果你之前使用VS Code，选择"是"可以让你的主题、快捷键、代码片段一键迁移过来。这省去了大量重新配置的时间。

**选择默认语言模型。** Cursor支持多种AI模型，包括它自家的**Composer**模型以及Claude和GPT系列。Composer是Cursor在2025年推出的自研编程模型，速度比同类智能模型快4倍，特别适合需要快速迭代的编程任务。初期我建议先使用默认选项——通常是自动选择最优模型，它会根据你的任务类型智能切换。

**登录账户。** Cursor需要你创建一个账户或使用Google账户登录。免费版每月有一定的使用额度，对于学习和轻度使用完全足够。如果你发现自己频繁超出额度，再考虑升级付费版。

完成这些步骤后，你应该能看到一个干净的编辑器界面。在2.0版本中，你会在右侧看到一个Agent面板，这是你与AI交互的主要入口。一切就绪，我们可以开始了。

## 认识Cursor的四种模式

在开始第一个任务之前，我想先介绍Cursor 2.0的四种核心模式。理解这些模式，能帮助你在不同的场景下选择最合适的工作方式。

### Agent模式：得力助手

这是默认模式，也是你用得最多的一种。在Agent模式下，AI可以自主探索你的代码库、编辑多个文件、运行命令、甚至自动修复错误。当你给它一个任务，它会像一个真正的同事一样去完成——理解需求、查找相关代码、修改文件、运行测试、处理问题。

你可以把它想象成一个能力强、主动性高的助手。你不需要告诉它每一步该怎么做，它自己会规划和执行。你只需要在开始时清晰地描述目标，在过程中审核结果。

### Ask模式：只答不改

有时候，你并不想让AI修改代码，只是想问一些问题。比如"这段代码是做什么的？""我们的项目里有没有处理支付的模块？""为什么这里要这样写？"这时候，Ask模式就派上用场了。

在Ask模式下，AI只能搜索和阅读你的代码，不能做任何修改。它的工作就是回答你的问题，帮你理解代码库。这对于学习新项目、理解别人的代码、或者在动手之前先调研情况非常有用。

### Plan模式：谋定后动

如果你要做一个复杂的任务——比如给项目添加一个完整的用户认证系统——直接开工可能会走进死胡同。Plan模式让AI先帮你规划，生成一个详细的实施方案，你可以审核、修改这个方案，确认无误后再开始执行。

Plan模式的工作流程是这样的：首先，AI会问你一些澄清问题，确保它理解你的需求；然后，它研究你的代码库，收集相关上下文；接着，它创建一个详细的实施计划；你审核这个计划，可以提出修改意见；最后，确认无误后，点击"Build"，AI开始按照计划执行。

这就像是建筑图纸和实际施工的关系。先画好图纸，检查确认，再开始盖楼，比边盖边改要靠谱得多。

### Debug模式：抽丝剥茧

当代码出了诡异的问题——明明逻辑看起来没问题，但运行结果就是不对——普通的调试方式可能会让你陷入困境。Debug模式专门为这种情况设计。

在这种模式下，AI不会直接猜测问题所在然后尝试修复，而是会先生成假设，然后添加日志语句来验证这些假设。它会让你重现问题，收集运行时的数据，然后根据实际的证据来定位根本原因。

这种方式更像是科学实验：提出假设、设计实验、收集数据、得出结论。对于那些难以复现的bug、竞态条件、性能问题，Debug模式往往能找到肉眼难以发现的真相。

### 模式切换

切换模式非常简单：

- 点击Agent面板顶部的模式下拉菜单，选择你需要的模式
- 按下 `Cmd+.`（Mac）或 `Ctrl+.`（Windows）快速切换
- 如果你使用Plan模式，可以按 `Shift+Tab` 在聊天输入框中切换到Plan模式

初学者不需要一开始就掌握所有模式。我建议先从Agent模式和Ask模式开始，等熟悉了基本操作，再尝试Plan模式和Debug模式。

## 第一个任务：让AI帮你写一个简单的函数

### 任务设计

为了让你体验完整的AI编程流程，我想设计一个简单但有意义的任务。这个任务应该足够简单，让你不被复杂逻辑困扰；但也应该足够完整，让你体验"描述需求-获得代码-理解代码-运行验证"的完整闭环。

我们来做这样一个任务：**写一个Python函数，计算两个日期之间的天数差。**

这个任务有几好处。首先，它足够常见——很多实际项目中都会用到日期计算。其次，它涉及一些你可能不了解的细节——比如如何处理日期格式、如何计算跨月跨年的情况——这正是让AI帮我们的好理由。最后，它的结果很容易验证——你可以心算或者用手机日历核对答案是否正确。

### 第一步：打开Agent面板

在Cursor中，你有两种主要方式与AI交互。

第一种是**内联编辑**。在编辑器的任意位置，按下 `Cmd+K`（Mac）或 `Ctrl+K`（Windows），会弹出一个输入框。你可以在这里描述你想做什么，AI会直接在当前位置生成或修改代码。这种方式适合小范围、具体的修改，比如"把这个变量重命名"、"在这里添加错误处理"。

第二种是**Agent面板**。按下 `Cmd+L`（Mac）或 `Ctrl+L`（Windows），会打开右侧的Agent面板。这是更强大的交互方式，你可以和AI进行多轮对话，让它理解更复杂的需求，甚至执行多文件的操作。

对于我们的第一个任务，我建议使用Agent面板。这样可以让你更清楚地看到AI的思考过程，也方便你提问和澄清。

### 第二步：向AI描述你的需求

打开Agent面板后，确保你处于 **Ask模式**（用于学习）或 **Agent模式**（可以直接修改代码）。我们先使用Ask模式来进行第一次交互，这样AI只会展示代码而不会直接修改文件。

在输入框中输入你的需求。很多人第一次做这件事时会感到不知所措——我该怎么描述？要多详细？会不会遗漏什么？

让我先帮你写一个"及格"版本的需求描述：

```
帮我写一个Python函数，计算两个日期之间的天数差。
```

按下回车，观察AI的反应。你会发现AI确实能理解这个需求，并给出一段代码。但是这个描述太简略了，AI可能会问：日期的格式是什么？是字符串还是日期对象？差值应该是正数还是可以接受负数？

所以让我教你写一个更好的需求描述——一个"优秀"版本：

```
帮我写一个Python函数diff_days(date1, date2)，计算两个日期之间的天数差。

要求：
1. 参数date1和date2都是字符串格式，如"2024-01-15"
2. 返回date2减去date1的天数，可以是正数或负数
3. 如果输入格式不正确，应该抛出有意义的错误信息
4. 不使用任何第三方库，只用Python标准库
```

你看，这个描述清晰地说明了：函数的签名是什么、参数的格式是什么、返回值应该是什么、有什么特殊要求。这样的描述让AI更容易给出符合你预期的代码。

发送这个消息后，等待几秒，AI会返回类似这样的回答：

```python
from datetime import datetime

def diff_days(date1, date2):
    """
    计算两个日期之间的天数差。

    参数:
        date1 (str): 起始日期，格式为 "YYYY-MM-DD"
        date2 (str): 结束日期，格式为 "YYYY-MM-DD"

    返回:
        int: date2 - date1 的天数差

    异常:
        ValueError: 当日期格式不正确时抛出
    """
    date_format = "%Y-%m-%d"

    try:
        d1 = datetime.strptime(date1, date_format)
        d2 = datetime.strptime(date2, date_format)
    except ValueError:
        raise ValueError(f"日期格式不正确，请使用 YYYY-MM-DD 格式。收到的输入: {date1}, {date2}")

    return (d2 - d1).days
```

### 第三步：理解AI给你的代码

拿到代码后，不要急着复制粘贴。我强烈建议你先理解这段代码在做什么。记住我们的原则：**你始终是决策者，你需要知道AI在做什么。**

让我们逐行解析这段代码：

```python
from datetime import datetime
```

这行导入了Python标准库中的`datetime`模块的`datetime`类。Python内置了对日期时间的处理，不需要安装额外的包。

```python
def diff_days(date1, date2):
```

定义了一个函数，接受两个参数。这是我们要求的函数签名。

```python
date_format = "%Y-%m-%d"
```

定义了一个日期格式字符串。`%Y`代表四位年份，`%m`代表两位月份，`%d`代表两位日期。所以`"2024-01-15"`就符合这个格式。

```python
try:
    d1 = datetime.strptime(date1, date_format)
    d2 = datetime.strptime(date2, date_format)
except ValueError:
    raise ValueError(f"日期格式不正确...")
```

这部分用`strptime`方法把字符串解析成日期对象。如果字符串格式不符合预期（比如你传入了"2024/01/15"），会抛出`ValueError`。我们捕获这个异常，重新抛出一个更友好的错误信息。

```python
return (d2 - d1).days
```

两个日期对象相减，得到一个`timedelta`对象。这个对象的`.days`属性就是相差的天数。

理解完代码后，你觉得这段代码满足你的需求吗？有什么可以改进的地方吗？

如果有疑问，你可以继续在Agent面板中追问。比如：

```
这个函数能处理闰年吗？
```

AI会解释：`datetime`模块已经内置了闰年的处理逻辑，所以2月29日在闰年是合法的，在非闰年会抛出错误——这正是我们想要的行为。

### 第四步：让Agent帮你创建文件并验证

现在，让我们切换到 **Agent模式**，让AI帮我们创建文件并运行测试。按下 `Cmd+.` 切换到Agent模式，然后输入：

```
请创建一个名为test_diff_days.py的文件，包含这个函数和以下测试用例，然后运行它验证结果是否正确：

1. diff_days("2024-01-01", "2024-01-10") 应该返回 9
2. diff_days("2024-01-10", "2024-01-01") 应该返回 -9
3. diff_days("2023-12-31", "2024-01-01") 应该返回 1（跨年）
4. diff_days("2024-02-28", "2024-03-01") 应该返回 2（2024是闰年）
```

在Agent模式下，Cursor会执行一系列操作：创建文件、写入代码、在终端中运行Python脚本。你可以在界面上看到它操作的每一步。如果一切顺利，你应该能看到测试通过的输出。恭喜你，你刚刚完成了第一次AI辅助编程！

这就是Cursor 2.0 Agent模式的魅力：它不只是给你建议，而是能真正帮你执行操作。当然，你始终拥有最终控制权——Agent在执行重要操作前会征求你的确认，你也可以随时查看和修改它所做的更改。

### 如果出错了怎么办？

假设运行测试时发现了一个错误：日期`"2024-02-30"`应该不存在，但程序给出了一些奇怪的结果而不是报错。这时候，你不需要自己去找问题，继续向AI描述：

```
我发现一个bug：当输入"2024-02-30"这样的非法日期时，程序没有报错。
请帮我修复这个问题。
```

AI会分析问题，告诉你：实际上`strptime`在解析"2024-02-30"时会自动变成"2024-03-01"，这是Python默认的行为。如果要严格验证日期，需要显式检查。然后它会给出修复方案，并且可以直接帮你在文件中修改代码。

你看，这就是AI辅助编程的魅力所在：你不必自己知道每个问题的答案，但你仍然可以通过与AI的对话，逐步发现和解决问题。

## 快捷键速查

为了让你更高效地使用Cursor，这里整理了一份常用快捷键：

| 功能 | Mac | Windows/Linux |
|------|-----|---------------|
| 打开内联编辑器 | `Cmd+K` | `Ctrl+K` |
| 打开Agent面板 | `Cmd+L` | `Ctrl+L` |
| 快速切换模式 | `Cmd+.` | `Ctrl+.` |
| 切换AI模型 | `Cmd+/` | `Ctrl+/` |
| 接受更改 | `Cmd+Enter` | `Ctrl+Enter` |
| 拒绝更改 | `Cmd+Backspace` | `Ctrl+Backspace` |

在使用内联编辑时，`Cmd+K`会唤起一个输入框，你描述需求后，AI会直接在代码中生成修改建议，你可以选择接受或拒绝。

在Agent面板中，你还可以使用一些特殊的符号来增强上下文：

- `@文件名` - 引用特定文件的内容
- `@Codebase` - 让AI搜索整个代码库
- `@Web` - 让AI搜索网络获取最新信息

这些功能在处理复杂任务时特别有用，能够帮助AI更准确地理解你的需求和项目上下文。

## 实践中的几个技巧

通过刚才的练习，你应该对AI编程有了初步的感觉。但实际工作中，你会遇到更复杂的情况。让我分享几个在实践中总结的技巧。

### 技巧一：先想清楚，再开口

很多人使用AI编程工具时，习惯于随便说一句话，然后等待结果。这种做法的问题在于：如果你自己都没想清楚要什么，AI就更不可能理解了。

好的提问习惯是这样的：在输入框里写下需求之后，先问自己一个问题——**如果一个人类同事看到这段话，他能准确理解我要什么吗？** 如果答案是"可能不行"，那就继续补充细节。

举个例子，你要处理一个Excel文件。一个模糊的描述是：

```
帮我写一个脚本处理Excel文件
```

一个清晰的描述是：

```
帮我写一个Python脚本，功能如下：
1. 读取当前目录下名为"data.xlsx"的Excel文件
2. 第一列是姓名，第二列是分数
3. 计算平均分、最高分、最低分
4. 把结果输出到一个新的Excel文件"result.xlsx"中
```

两个描述的差别显而易见。

### 技巧二：把大任务拆成小任务

如果你的任务很复杂，不要指望一次对话就能完美解决。把大任务拆成小任务，逐步推进。

假设你想做一个网页爬虫，去抓取某个网站的数据。与其一次性说"帮我做一个爬虫"，不如这样分步进行：

```
第一步：帮我写一个函数，获取某个URL的网页内容
（测试这个函数确实能获取到内容）
```

```
第二步：现在我有网页HTML内容了，帮我写一个函数，从中提取所有链接
（测试提取是否正确）
```

```
第三步：我只需要提取特定class的链接，帮我修改函数
（继续细化）
```

这种方式的好处是：每一步都可以验证，如果出错，你能快速定位是哪一步出了问题。而且，AI在每一轮对话中只需要解决一个具体的问题，回答质量会更高。

### 技巧三：主动提供上下文

AI不知道你知道的事情。如果你的项目有一些特殊的约束或背景信息，主动告诉AI。

比如，你的公司有一个内部的代码规范："所有函数必须有docstring，所有变量名必须用snake_case"。你在第一次对话时就可以告诉AI：

```
在写代码之前请注意，我需要遵循以下代码规范：
1. 所有函数必须有docstring
2. 变量名使用snake_case
3. 每行不超过80个字符
```

这些信息会帮助AI生成更符合你需求的代码。

在Cursor中，你还可以创建一个 `.cursorrules` 文件（或 `.cursor/rules/` 目录下的规则文件），把这些规范持久化保存下来。这样，每次与AI对话时，它都会自动遵循这些规则，你不需要每次重复说明。

### 技巧四：要求AI解释，而不是默默接受

当AI给你一段代码时，不要急着复制粘贴。请求AI解释这段代码在做什么，每一部分的作用是什么。

```
请解释一下这段代码每一部分的作用
```

这样做有两个好处。首先，你在学习——通过AI的解释，你会学到新的知识。其次，你在验证——如果AI无法清晰解释某段代码，或者解释得含糊其辞，这可能意味着代码本身有问题。

### 技巧五：迭代优化，不要期望一步到位

现实生活中，很少有一次性就完美的代码。你应该做好心理准备：AI给出的第一版代码很可能不是最佳版本。

当你拿到代码后，审视它，思考它。哪里可以更简洁？哪里可能有问题？哪里不符合你的习惯？然后，把这些想法作为修改建议反馈给AI：

```
这个函数能工作，但我想做一些改进：
1. 变量名能不能更有意义？
2. 能不能添加类型注解，让代码更清晰？
3. 错误信息能否更具体？
```

通过这种迭代的对话，你会得到越来越好的代码。

### 技巧六：善用Plan模式处理复杂任务

当你面临一个复杂的任务时，比如"给项目添加用户认证系统"或"重构整个数据处理模块"，不要直接跳进Agent模式开始改代码。先用Plan模式让AI帮你规划。

Plan模式会帮你：

1. 梳理需求的细节，发现你可能没想清楚的地方
2. 研究现有代码，理解当前的实现方式
3. 生成一个详细的实施方案，列出要修改哪些文件、要添加哪些功能
4. 让你有机会在动手之前调整方向

这就像是建筑图纸——在盖楼之前先画好图纸，检查确认，比边盖边改要高效得多，也安全得多。

## 一个完整的思考框架

总结刚才的实践和技巧，我想给你一个思考框架。每次使用AI编程助手时，你可以问自己四个问题：

**第一个问题：我真的理解要做什么吗？**

如果你不能清晰地向AI描述需求，说明你也还没想清楚。花时间把需求想透，比急匆匆地开始写代码更有效率。复杂任务？先用Plan模式。

**第二个问题：AI输出的代码，我理解每一行在做什么吗？**

不要接受你不理解的代码。每一行代码你都应该能解释它的作用。如果有不确定的地方，问AI，或者自己查资料搞清楚。

**第三个问题：我验证过这段代码是正确的吗？**

AI不保证正确性，测试是你的责任。想几个测试用例，跑一跑，看看结果是否符合预期。不要相信"应该没问题"，要确认"确实没问题"。

**第四个问题：这段代码符合我的需求和场景吗？**

AI给出的是通用解决方案，你的场景可能有特殊的要求。比如你的项目有特定的代码风格、有特殊的性能要求、有安全约束……这些，你比AI更清楚。由你来判断代码是否适合你的情况。

这四个问题构成了一个完整的检查清单。每次使用AI编程，过一遍这个清单，你的代码质量和学习效果都会有显著提升。

## 常见的心态问题

在结束这一章之前，我想聊聊一些常见的心理障碍。很多人在初次使用AI编程工具时，会有一些顾虑或困惑。

### "我用AI写代码，是不是作弊？"

这是最常见的心态问题。有些人觉得，代码应该是自己一个字一个字敲出来的，用AI就像是抄作业。

我想换一个角度来思考这个问题。想一想，程序员日常工作中有多少事情是"自己原创"的？你用的是别人写的编译器，用的是别人写的框架，调用的是别人写的库，抄的是Stack Overflow上的代码片段。编程从来就不是"从零开始创造一切"，而是"站在巨人的肩膀上组合解决方案"。

AI编程助手只是这个"巨人肩膀"的新版本。它帮你写代码，就像框架帮你处理底层细节、库帮你实现通用功能一样。关键不在于每个字都是你敲的，而在于你理解这段代码在做什么、为什么这样做、是否满足你的需求。

当然，如果你正在学习编程，我强烈建议你不要只依赖AI。自己动手写一些代码，会帮助你对编程建立更深的直觉。AI是你的学习伙伴，不是替代你学习的捷径。

### "AI写的代码会不会有后门？"

这是一个合理的安全担忧。如果你让AI帮你生成处理敏感数据的代码，怎么确保它不包含恶意逻辑？

实际上，目前主流的AI模型（如Claude、GPT、Composer）都是训练好的模型，它们"决定"输出什么完全取决于你的输入和模型本身的能力。模型本身不会"主观上想害你"。但这不意味着AI生成的代码一定安全。

风险主要来自这几个方面：

第一，AI不知道你的安全要求。它可能生成一段代码使用了不安全的方式处理密码、连接数据库、处理用户输入。这些安全隐患是真实的，因为AI没有受过专门的安全训练，它只知道生成"能工作"的代码。

第二，AI可能使用了过时的实践。AI模型的训练数据有时间截止，有些最佳实践可能已经更新。比如，某个库的新版本改变了API用法，但AI还在使用旧版本的方式调用。

第三，你的输入会发送到云端服务器。如果你把敏感代码发送给云端AI服务，这本身就是一个数据泄露的风险点。对于敏感项目，应该使用支持私有部署的方案。

所以，关键在于：**不要盲目信任AI生成的代码，尤其是涉及安全的敏感部分。** 审慎审查，必要时请教有安全经验的人。

### "我用的AI回答很差，怎么办？"

有时候，你问的问题得不到满意的回答，这不一定是因为AI能力不行，可能只是你问的方式不对。

回忆一下我们前面提到的：需求描述是否清晰？上下文是否足够？任务是否拆分得足够细？很多时候，调整提问方式，就能获得更好的回答。

当然，不同模型确实有不同的擅长领域。Claude在解释概念、写长文档方面表现更好，GPT在某些推理任务上更强，Composer在快速代码迭代上更有优势。你可以按 `Cmd+/` 在不同模型间切换，试试看哪个回答更符合你的预期。

### "AI会不会让程序员失业？"

这是一个很多人都在讨论的问题，我也就此说说我自己的看法。

我的判断是：AI不会让程序员失业，但会让"只会机械写代码"的人越来越难生存。原因是这样的。

编程工作的本质从来就不是"敲代码"，而是"解决问题"。理解业务需求、设计方案、权衡取舍、排查问题、优化性能——这些才是程序员的核心价值。写代码，只是表达的载体。

AI能帮你更快地完成"表达"这一步，但它不能替代你的"解决问题"能力。它不知道什么功能对用户更重要，不知道一行代码背后有什么业务逻辑，不知道某个方案的技术债务会在两年后爆发。这些东西，需要人的判断和经验。

所以，与其担心被AI替代，不如提升那些AI无法替代的能力：对业务的深刻理解、对技术的判断力、解决复杂问题的经验。有了这些能力，AI会成为你更强的武器，而不是你的竞争对手。

## 小结

这一章，我们一起完成了第一次AI编程实践。

我们学习了如何安装和配置Cursor 2.0，一个真正AI原生的代码编辑器。它以Agent为中心的新界面设计，代表着开发工具的一次范式转变——从"操作文件"到"描述目标"，让AI帮你处理细节。

我们认识了Cursor的四种核心模式：Agent模式用于执行复杂任务，Ask模式用于提问和学习，Plan模式用于规划和设计，Debug模式用于排查疑难问题。选择合适的模式，能让你事半功倍。

我们完成了一个完整的任务：让AI帮我们写一个计算日期差的函数。这个过程包括：清晰地描述需求、理解AI返回的代码、让Agent创建文件并运行验证、迭代修复发现的问题。

我们总结了实践中的六个技巧：先想清楚再开口、把大任务拆成小任务、主动提供上下文、要求AI解释代码、迭代优化不要期望一步到位、善用Plan模式处理复杂任务。

我们建立了一个思考框架：每次使用AI时问自己四个问题——我真的理解要做什么吗？我理解每一行代码吗？我验证过代码正确吗？代码符合我的场景吗？

最后，我们讨论了一些常见的心态问题：用AI不是作弊，但要理解你用的代码；要审慎对待AI生成的代码，尤其是安全相关的部分；AI不会替代程序员，但会替代"只会机械写代码"的人。

从下一章开始，我们将进入更详细的工具学习。我会带你深入了解各个AI编程工具的具体使用方法，让你能够根据自己的情况做出最佳选择。但在此之前，我希望你能够完成下面的练习——实践是学习编程的唯一途径。

## 练习

**动手实践题**：请在Cursor中完成以下任务：

1. 让AI帮你写一个Python函数`count_words(text)`，统计一段文本中每个单词出现的次数，返回一个字典。
2. 思考一下：这个函数对中文文本有效吗？如果没有效果，该怎么修改？
3. 使用Agent模式让AI帮你创建文件并运行测试。

**模式体验题**：

1. 使用Ask模式问AI："这个函数的时间复杂度是多少？有没有更高效的实现方式？"
2. 使用Plan模式规划一个稍微复杂的任务，比如"给这个日期计算功能添加命令行界面"。观察AI是如何生成计划的，然后决定是否执行。

**对比思考题**：如果你之前使用过ChatGPT或其他AI对话工具，请对比一下在对话工具中"让AI帮你写代码"和在Cursor中使用Agent模式的区别。你会发现体验上有什么不同？

**反思题**：在完成第一个任务的过程中，你是否遇到AI给出的代码与你预期不符的情况？你是如何处理的？这个经历让你对"向AI描述需求"这件事有什么新的认识？

**自我挑战题**：尝试一个比日期差计算稍难一点的任务——比如"写一个函数，判断一个字符串是否是有效的邮箱地址"。看看你能否通过清晰的描述让AI一次性给出符合你预期的代码。如果不行，分析一下是描述的问题还是任务本身难度的问题。